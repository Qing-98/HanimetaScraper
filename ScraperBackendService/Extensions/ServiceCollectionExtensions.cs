using Microsoft.Playwright;using ScraperBackendService.Configuration;using ScraperBackendService.Core.Net;using ScraperBackendService.Providers.DLsite;using ScraperBackendService.Providers.Hanime;using ScraperBackendService.AntiCloudflare;using Microsoft.Extensions.DependencyInjection;using Microsoft.Extensions.Logging;using System.Threading;using ScraperBackendService.Core.Logging;using Microsoft.Extensions.Hosting;namespace ScraperBackendService.Extensions;/// <summary>/// Service registration extension methods for dependency injection configuration./// Provides streamlined setup of scraping services, network clients, and content providers/// with proper lifecycle management and resource cleanup./// </summary>/// <remarks>/// This extension configures the complete scraping pipeline including:/// - Playwright browser management with automatic lifecycle handling/// - Provider-specific concurrency and rate limiting/// - Network clients for different scraping strategies (HTTP vs. browser-based)/// - Proper resource disposal and cleanup on application shutdown/// </remarks>/// <example>/// Usage in Program.cs:/// var builder = WebApplication.CreateBuilder(args);/// var serviceConfig = new ServiceConfiguration();/// builder.Configuration.GetSection(ServiceConfiguration.SectionName).Bind(serviceConfig);////// // Register all scraping services/// builder.Services.AddScrapingServices(serviceConfig);////// var app = builder.Build();////// // Services are now available for injection:/// // - HanimeProvider (with PlaywrightNetworkClient)/// // - DlsiteProvider (with HttpNetworkClient)/// // - IBrowser (Playwright Chromium instance)/// // - ServiceConfiguration (bound to config)/// </example>public static class ServiceCollectionExtensions{    /// <summary>    /// Registers all scraping-related services including configuration, network clients, and content providers.    /// Sets up dependency injection for the complete scraping pipeline with proper lifecycle management.    /// </summary>    /// <param name="services">Service collection to register services with</param>    /// <param name="config">Service configuration containing operational parameters and limits</param>    /// <returns>Service collection for method chaining</returns>    /// <remarks>    /// This method configures:    /// 1. Service configuration options for dependency injection    /// 2. Provider-specific concurrency and rate limiters    /// 3. Playwright browser instance with proper lifecycle management    /// 4. Network clients (HTTP and Playwright-based)    /// 5. Content providers (Hanime and DLsite)    /// 6. Cleanup services for proper resource disposal    /// </remarks>    /// <example>    /// var config = new ServiceConfiguration    /// {    ///     Port = 8585,    ///     Host = "0.0.0.0",    ///     AuthToken = "secret-token",    ///     HanimeMaxConcurrentRequests = 5,    ///     DlsiteMaxConcurrentRequests = 5,    ///     RequestTimeoutSeconds = 60,    ///     HanimeRateLimitSeconds = 30,    ///     DlsiteRateLimitSeconds = 30    /// };    ///    /// services.AddScrapingServices(config);    ///    /// // Registered services:    /// // - ServiceConfiguration (configured options)    /// // - IBrowser (Playwright Chromium browser)    /// // - PlaywrightNetworkClient (for JavaScript-heavy sites)    /// // - HttpNetworkClient (for static content)    /// // - HanimeProvider (uses Playwright for dynamic content)    /// // - DlsiteProvider (uses HTTP for efficient scraping)    /// // - Concurrency and rate limiters for each provider    /// </example>    public static IServiceCollection AddScrapingServices(this IServiceCollection services, ServiceConfiguration config)    {        // Register configuration options for dependency injection        services.Configure<ServiceConfiguration>(opt =>        {            opt.Port = config.Port;            opt.Host = config.Host;            opt.AuthToken = config.AuthToken;            opt.TokenHeaderName = config.TokenHeaderName;            opt.RequestTimeoutSeconds = config.RequestTimeoutSeconds;            opt.HanimeMaxConcurrentRequests = config.HanimeMaxConcurrentRequests;            opt.DlsiteMaxConcurrentRequests = config.DlsiteMaxConcurrentRequests;            opt.EnableAggressiveMemoryOptimization = config.EnableAggressiveMemoryOptimization;            opt.ChallengeAutoWaitSeconds = config.ChallengeAutoWaitSeconds;            opt.ChallengeAutoWaitSlowSeconds = config.ChallengeAutoWaitSlowSeconds;            opt.HanimeRateLimitSeconds = config.HanimeRateLimitSeconds;            opt.DlsiteRateLimitSeconds = config.DlsiteRateLimitSeconds;        });        // Register provider-specific concurrency limiters with configured limits        var hanimeLimit = config.HanimeMaxConcurrentRequests;        var dlsiteLimit = config.DlsiteMaxConcurrentRequests;        // Use typed concurrency limiter classes for better type safety        services.AddSingleton(new ScraperBackendService.Core.Concurrency.HanimeConcurrencyLimiter(hanimeLimit));        services.AddSingleton(new ScraperBackendService.Core.Concurrency.DlsiteConcurrencyLimiter(dlsiteLimit));        // Register provider-specific rate limiters with configured intervals        var hanimeRateInterval = TimeSpan.FromSeconds(config.HanimeRateLimitSeconds);        var dlsiteRateInterval = TimeSpan.FromSeconds(config.DlsiteRateLimitSeconds);        services.AddSingleton(new ScraperBackendService.Core.Concurrency.HanimeRateLimiter(hanimeRateInterval));        services.AddSingleton(new ScraperBackendService.Core.Concurrency.DlsiteRateLimiter(dlsiteRateInterval));        // Register PlaywrightService as singleton to manage browser lifecycle        services.AddSingleton<PlaywrightService>();        // Register Playwright browser as singleton with proper disposal        services.AddSingleton<IBrowser>(sp =>        {            var playwrightService = sp.GetRequiredService<PlaywrightService>();            return playwrightService.GetBrowserAsync().GetAwaiter().GetResult();        });        // Register PlaywrightContextManager as singleton using the browser instance        services.AddSingleton<PlaywrightContextManager>(sp =>        {            var browser = sp.GetRequiredService<IBrowser>();            var logger = sp.GetRequiredService<ILogger<PlaywrightContextManager>>();            var options = new ScrapeRuntimeOptions            {                ChallengeAutoWaitMs = config.ChallengeAutoWaitSeconds * 1000,                ChallengeAutoWaitSlowMs = config.ChallengeAutoWaitSlowSeconds * 1000            };                        return new PlaywrightContextManager(browser, logger, options);        });        // Register PlaywrightNetworkClient using context manager (recommended approach)        services.AddScoped<PlaywrightNetworkClient>(sp =>        {            var ctxMgr = sp.GetRequiredService<PlaywrightContextManager>();            var logger = sp.GetRequiredService<ILogger<PlaywrightNetworkClient>>();            return new PlaywrightNetworkClient(ctxMgr, logger);        });        // Register HttpNetworkClient via IHttpClientFactory to ensure proper connection pooling        services.AddHttpClient<HttpNetworkClient>();        // Register content providers with appropriate network clients        services.AddScoped<HanimeProvider>(sp =>        {            var playwrightClient = sp.GetRequiredService<PlaywrightNetworkClient>();            var logger = sp.GetRequiredService<ILogger<HanimeProvider>>();            return new HanimeProvider(playwrightClient, logger);        });        services.AddScoped<DlsiteProvider>(sp =>        {            var httpClient = sp.GetRequiredService<HttpNetworkClient>();            var logger = sp.GetRequiredService<ILogger<DlsiteProvider>>();            return new DlsiteProvider(httpClient, logger);        });        return services;    }}/// <summary>/// Service for managing Playwright lifecycle including browser creation and disposal./// Ensures proper resource cleanup on application shutdown and handles initialization errors gracefully./// </summary>/// <remarks>/// This service:/// - Initializes the Playwright browser instance asynchronously during startup/// - Provides a thread-safe way to access the browser instance/// - Handles browser disposal and cleanup on service shutdown/// - Implements proper error handling for initialization failures/// </remarks>public class PlaywrightService : IAsyncDisposable, IDisposable{    private readonly ILogger<PlaywrightService> _logger;    private readonly TaskCompletionSource<IBrowser> _browserTcs = new();    private IPlaywright? _playwright;    private IBrowser? _browser;    private bool _disposed = false;    /// <summary>    /// Initializes a new instance of the PlaywrightService.    /// Automatically starts browser initialization in the background.    /// </summary>    /// <param name="logger">Logger for tracking initialization and disposal events</param>    public PlaywrightService(ILogger<PlaywrightService> logger)    {        _logger = logger;        // Start browser initialization immediately in background thread        _ = Task.Run(InitializeBrowserAsync);    }    /// <summary>    /// Gets the browser instance, waiting for initialization if necessary.    /// This method is thread-safe and can be called multiple times.    /// </summary>    /// <returns>The initialized browser instance</returns>    /// <exception cref="Exception">Thrown if browser initialization fails</exception>    public async Task<IBrowser> GetBrowserAsync()    {        return await _browserTcs.Task.ConfigureAwait(false);    }    /// <summary>    /// Initializes the Playwright browser instance with optimized settings for scraping.    /// Configures browser arguments to avoid detection and improve performance.    /// </summary>    private async Task InitializeBrowserAsync()    {        try        {            _logger.LogDebug("Initializing Playwright browser...");                        _playwright = await Playwright.CreateAsync().ConfigureAwait(false);            _browser = await _playwright.Chromium.LaunchAsync(new BrowserTypeLaunchOptions            {                Headless = true,                // Headless = false, // Uncomment for debugging                Args = new[] {                    "--no-sandbox",                    "--disable-blink-features=AutomationControlled",                    "--disable-dev-shm-usage",                    "--disable-gpu"                }            }).ConfigureAwait(false);                        // Only initialization success uses LogAlways            _logger.LogAlways("PlaywrightService", "Playwright browser initialized successfully");            _browserTcs.SetResult(_browser);        }        catch (Exception ex)        {            _logger.LogError(ex, "Failed to initialize Playwright browser");            _browserTcs.SetException(ex);        }    }    /// <summary>    /// Disposes of Playwright resources asynchronously.    /// Closes the browser and disposes of the Playwright instance.    /// </summary>    public async ValueTask DisposeAsync()    {        if (_disposed) return;        try        {            _logger.LogDebug("Disposing Playwright resources...");                        if (_browser != null && _browser.IsConnected)            {                await _browser.CloseAsync().ConfigureAwait(false);                _logger.LogDebug("Browser closed successfully");            }                        if (_playwright != null)            {                _playwright.Dispose();                _logger.LogDebug("Playwright disposed successfully");            }        }        catch (Exception ex)        {            _logger.LogWarning(ex, "Error during Playwright disposal");        }        finally        {            _disposed = true;        }    }    /// <summary>    /// Synchronously disposes of Playwright resources.    /// Calls DisposeAsync and blocks until completion.    /// </summary>    public void Dispose()    {        try        {            DisposeAsync().GetAwaiter().GetResult();        }        catch (Exception ex)        {            _logger.LogWarning(ex, "Error during synchronous Playwright disposal");        }    }}/// <summary>/// Hosted service to ensure proper cleanup of Playwright resources on application shutdown./// Coordinates the disposal of PlaywrightContextManager and PlaywrightService in the correct order./// </summary>/// <remarks>/// This service ensures that:/// 1. Browser contexts are closed before the browser instance/// 2. The browser is properly disposed before application shutdown/// 3. All resources are cleaned up even if errors occur during shutdown/// </remarks>public class PlaywrightCleanupService : IHostedService{    private readonly PlaywrightService _playwrightService;    private readonly PlaywrightContextManager _contextManager;    private readonly ILogger<PlaywrightCleanupService> _logger;    /// <summary>    /// Initializes a new instance of the PlaywrightCleanupService.    /// </summary>    /// <param name="playwrightService">The Playwright service to clean up</param>    /// <param name="contextManager">The context manager to dispose first</param>    /// <param name="logger">Logger for tracking cleanup events</param>    public PlaywrightCleanupService(        PlaywrightService playwrightService,        PlaywrightContextManager contextManager,        ILogger<PlaywrightCleanupService> logger)    {        _playwrightService = playwrightService;        _contextManager = contextManager;        _logger = logger;    }    /// <summary>    /// Starts the cleanup service. No action required during startup.    /// </summary>    /// <param name="cancellationToken">Cancellation token</param>    /// <returns>Completed task</returns>    public Task StartAsync(CancellationToken cancellationToken)    {        _logger.LogDebug("Playwright cleanup service started");        return Task.CompletedTask;    }    /// <summary>    /// Stops the cleanup service and performs proper resource disposal.    /// Ensures contexts are disposed before the browser service.    /// </summary>    /// <param name="cancellationToken">Cancellation token</param>    /// <returns>Task representing the async cleanup operation</returns>    public async Task StopAsync(CancellationToken cancellationToken)    {        _logger.LogDebug("Stopping Playwright cleanup service...");                try        {            // First dispose context manager (closes all contexts)            await _contextManager.DisposeAsync().ConfigureAwait(false);                        // Then dispose the browser service            await _playwrightService.DisposeAsync().ConfigureAwait(false);                        _logger.LogInformation("Playwright resources cleaned up successfully");        }        catch (Exception ex)        {            _logger.LogError(ex, "Error during Playwright cleanup");        }    }}