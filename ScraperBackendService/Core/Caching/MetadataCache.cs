using System.Collections.Concurrent;using Microsoft.Extensions.Caching.Memory;using ScraperBackendService.Models;using ScraperBackendService.Core.Logging;namespace ScraperBackendService.Core.Caching;/// <summary>/// High-performance metadata cache with TTL support to prevent duplicate scraping operations./// Caches both successful results and null results to avoid repeated failed requests./// </summary>public class MetadataCache : IDisposable{    private readonly IMemoryCache _cache;    private readonly ILogger<MetadataCache> _logger;    private readonly TimeSpan _defaultTtl;    private readonly TimeSpan _nullResultTtl;        // Track cache statistics    private long _hitCount;    private long _missCount;    private long _evictionCount;    public MetadataCache(ILogger<MetadataCache> logger, TimeSpan? defaultTtl = null, TimeSpan? nullResultTtl = null)    {        _logger = logger;        _defaultTtl = defaultTtl ?? TimeSpan.FromMinutes(2); // 2 minutes for successful results        _nullResultTtl = nullResultTtl ?? TimeSpan.FromMinutes(2);  // 2 minutes for null results                var options = new MemoryCacheOptions        {            SizeLimit = 100, // Maximum 100 cached items            CompactionPercentage = 0.2 // Remove 20% when limit reached        };                _cache = new MemoryCache(options);                _logger.LogDebug("CacheInit", $"Metadata cache initialized with TTL: {_defaultTtl}, Null TTL: {_nullResultTtl}");    }    /// <summary>    /// Gets or sets cached metadata for the specified provider and ID.    /// Returns both the metadata and cache hit information.    /// </summary>    /// <param name="provider">Provider name (e.g., "hanime", "dlsite")</param>    /// <param name="id">Content ID</param>    /// <param name="factory">Factory function to create metadata if not cached</param>    /// <param name="ct">Cancellation token</param>    /// <returns>Tuple containing cached or newly created metadata and cache hit status</returns>    public async Task<(Metadata?, bool wasCached)> GetOrSetWithCacheInfoAsync(string provider, string id, Func<Task<Metadata?>> factory, CancellationToken ct = default)    {        var cacheKey = $"{provider}:{id}";                // Try to get from cache first        if (_cache.TryGetValue(cacheKey, out var cachedResult))        {            Interlocked.Increment(ref _hitCount);            _logger.LogDebug("CacheHit", "Cache entry found", cacheKey);            return (cachedResult as Metadata, true);        }        Interlocked.Increment(ref _missCount);        _logger.LogDebug("CacheMiss", "Cache entry not found, fetching from provider", cacheKey);        try        {            // Fetch from provider            var metadata = await factory().ConfigureAwait(false);                        // Cache the result (even if null)            var ttl = metadata != null ? _defaultTtl : _nullResultTtl;            var cacheOptions = new MemoryCacheEntryOptions            {                AbsoluteExpirationRelativeToNow = ttl,                Size = 1,                Priority = CacheItemPriority.Normal            };            // Add eviction callback for statistics            cacheOptions.RegisterPostEvictionCallback((key, value, reason, state) =>            {                Interlocked.Increment(ref _evictionCount);                _logger.LogDebug("CacheEviction", $"Entry evicted: {reason}", key.ToString());            });            _cache.Set(cacheKey, metadata, cacheOptions);                        _logger.LogDebug("CacheSet", $"Entry cached with TTL {ttl} (Success: {metadata != null})", cacheKey);                        return (metadata, false);        }        catch (Exception ex)        {            _logger.LogFailure("CacheFetch", "Failed to fetch metadata from provider", cacheKey, ex);            throw;        }    }    /// <summary>    /// Gets or sets cached metadata for the specified provider and ID.    /// </summary>    /// <param name="provider">Provider name (e.g., "hanime", "dlsite")</param>    /// <param name="id">Content ID</param>    /// <param name="factory">Factory function to create metadata if not cached</param>    /// <param name="ct">Cancellation token</param>    /// <returns>Cached or newly created metadata</returns>    public async Task<Metadata?> GetOrSetAsync(string provider, string id, Func<Task<Metadata?>> factory, CancellationToken ct = default)    {        var (result, _) = await GetOrSetWithCacheInfoAsync(provider, id, factory, ct);        return result;    }    /// <summary>    /// Removes cached metadata for the specified provider and ID.    /// </summary>    public void Remove(string provider, string id)    {        var cacheKey = $"{provider}:{id}";        _cache.Remove(cacheKey);        _logger.LogDebug("CacheRemove", "Cache entry removed", cacheKey);    }    /// <summary>    /// Clears all cached metadata.    /// </summary>    public void Clear()    {        if (_cache is MemoryCache memoryCache)        {            memoryCache.Compact(1.0); // Remove all entries        }                // Reset statistics        Interlocked.Exchange(ref _hitCount, 0);        Interlocked.Exchange(ref _missCount, 0);        Interlocked.Exchange(ref _evictionCount, 0);                _logger.LogSuccess("CacheClear", "All cache entries cleared");    }    /// <summary>    /// Gets cache statistics.    /// </summary>    public CacheStatistics GetStatistics()    {        var totalRequests = _hitCount + _missCount;        var hitRatio = totalRequests > 0 ? (double)_hitCount / totalRequests : 0.0;                return new CacheStatistics        {            HitCount = _hitCount,            MissCount = _missCount,            EvictionCount = _evictionCount,            HitRatio = hitRatio,            TotalRequests = totalRequests        };    }    /// <summary>    /// Tries to get cached metadata synchronously without triggering any async operations.    /// Used for quick cache checks before acquiring concurrency slots.    /// </summary>    /// <param name="provider">Provider name (e.g., "hanime", "dlsite")</param>    /// <param name="id">Content ID</param>    /// <returns>Cached metadata if found, null otherwise</returns>    public Metadata? TryGetCached(string provider, string id)    {        var cacheKey = $"{provider}:{id}";                if (_cache.TryGetValue(cacheKey, out var cachedResult))        {            Interlocked.Increment(ref _hitCount);            _logger.LogDebug("CacheHit", "Cache entry found (sync check)", cacheKey);            return cachedResult as Metadata;        }        return null;    }    /// <summary>    /// Sets metadata in cache without any async operations.    /// Used when we already have the data and just want to cache it.    /// </summary>    /// <param name="provider">Provider name (e.g., "hanime", "dlsite")</param>    /// <param name="id">Content ID</param>    /// <param name="metadata">Metadata to cache (can be null)</param>    public void SetCached(string provider, string id, Metadata? metadata)    {        var cacheKey = $"{provider}:{id}";                // Cache the result (even if null)        var ttl = metadata != null ? _defaultTtl : _nullResultTtl;        var cacheOptions = new MemoryCacheEntryOptions        {            AbsoluteExpirationRelativeToNow = ttl,            Size = 1,            Priority = CacheItemPriority.Normal        };        // Add eviction callback for statistics        cacheOptions.RegisterPostEvictionCallback((key, value, reason, state) =>        {            Interlocked.Increment(ref _evictionCount);            _logger.LogDebug("CacheEviction", $"Entry evicted: {reason}", key.ToString());        });        _cache.Set(cacheKey, metadata, cacheOptions);                _logger.LogDebug("CacheSet", $"Entry cached with TTL {ttl} (Success: {metadata != null})", cacheKey);    }    public void Dispose()    {        var stats = GetStatistics();        _logger.LogDebug("CacheDispose", $"Disposing metadata cache. Hits={stats.HitCount}, Misses={stats.MissCount}, Hit Ratio={stats.HitRatio:P2}");                _cache?.Dispose();    }}/// <summary>/// Cache performance statistics./// </summary>public class CacheStatistics{    public long HitCount { get; set; }    public long MissCount { get; set; }    public long EvictionCount { get; set; }    public double HitRatio { get; set; }    public long TotalRequests { get; set; }}