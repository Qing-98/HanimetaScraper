using System.Collections.Concurrent;namespace ScraperBackendService.Core.Concurrency;/// <summary>/// Rate limiter that enforces minimum time intervals between consecutive cache-miss requests/// for each concurrency slot. Each slot has its own independent timer./// </summary>/// <remarks>/// When a request hits the cache, no rate limiting is applied./// When a request misses the cache, the slot must wait for the configured interval/// since its last cache-miss request before allowing another cache-miss request./// </remarks>public class ProviderRateLimiter{    private readonly TimeSpan _minInterval;    private readonly ConcurrentDictionary<int, DateTimeOffset> _slotLastRequestTime;    private static readonly TimeSpan Epsilon = TimeSpan.FromMilliseconds(10);        /// <summary>    /// Gets the provider name for this rate limiter instance.    /// </summary>    public string ProviderName { get; }    /// <summary>    /// Initializes a new instance of the ProviderRateLimiter class.    /// </summary>    /// <param name="minInterval">Minimum interval between consecutive requests</param>    /// <param name="providerName">Optional provider name for identification</param>    public ProviderRateLimiter(TimeSpan minInterval, string? providerName = null)    {        _minInterval = minInterval;        _slotLastRequestTime = new ConcurrentDictionary<int, DateTimeOffset>();        ProviderName = providerName ?? "Unknown";    }    /// <summary>    /// Checks if the slot can proceed with a cache-miss request, and waits if necessary.    /// Does NOT update the last request time - caller must call RecordRequestComplete after successful operation.    /// </summary>    /// <param name="slotId">The concurrency slot ID (0-based index)</param>    /// <param name="ct">Cancellation token</param>    /// <returns>Task that completes when the rate limit allows the request</returns>    public async Task WaitIfNeededAsync(int slotId, CancellationToken ct)    {        if (_minInterval == TimeSpan.Zero)        {            // Rate limiting disabled            return;        }        var now = DateTimeOffset.UtcNow;                // Get the last request time for this slot        if (_slotLastRequestTime.TryGetValue(slotId, out var lastRequestTime))        {            var elapsed = now - lastRequestTime;            var remaining = _minInterval - elapsed;                        if (remaining > Epsilon)            {                // Need to wait                await Task.Delay(remaining, ct).ConfigureAwait(false);            }        }                // NOTE: Do NOT update timestamp here - caller must call RecordRequestComplete()         // after successful operation to avoid updating timestamp on failures    }    /// <summary>    /// Records that a request was successfully completed for the given slot.    /// Should be called after a successful operation to update the rate limit timer.    /// </summary>    /// <param name="slotId">The concurrency slot ID</param>    public void RecordRequestComplete(int slotId)    {        _slotLastRequestTime[slotId] = DateTimeOffset.UtcNow;    }    /// <summary>    /// Calculates how much time needs to wait before the next cache-miss request for a slot.    /// </summary>    /// <param name="slotId">The concurrency slot ID</param>    /// <returns>TimeSpan indicating wait time, or TimeSpan.Zero if no wait needed</returns>    public TimeSpan GetWaitTime(int slotId)    {        if (_minInterval == TimeSpan.Zero)        {            return TimeSpan.Zero;        }        if (_slotLastRequestTime.TryGetValue(slotId, out var lastRequestTime))        {            var elapsed = DateTimeOffset.UtcNow - lastRequestTime;            var remaining = _minInterval - elapsed;            return remaining > Epsilon ? remaining : TimeSpan.Zero;        }        return TimeSpan.Zero;    }    /// <summary>    /// Clears the rate limit history for all slots.    /// </summary>    public void Reset()    {        _slotLastRequestTime.Clear();    }    /// <summary>    /// Gets statistics about slot usage.    /// </summary>    public RateLimiterStatistics GetStatistics()    {        var now = DateTimeOffset.UtcNow;        var activeSlots = _slotLastRequestTime.Count;        var waitingSlots = 0;        foreach (var kvp in _slotLastRequestTime)        {            var elapsed = now - kvp.Value;            if (elapsed < _minInterval)            {                waitingSlots++;            }        }        return new RateLimiterStatistics        {            ActiveSlots = activeSlots,            WaitingSlots = waitingSlots,            MinInterval = _minInterval        };    }}/// <summary>/// Rate limiter statistics./// </summary>public class RateLimiterStatistics{    public int ActiveSlots { get; set; }    public int WaitingSlots { get; set; }    public TimeSpan MinInterval { get; set; }}