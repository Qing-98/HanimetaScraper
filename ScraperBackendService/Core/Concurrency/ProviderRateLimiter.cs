using System.Collections.Concurrent;namespace ScraperBackendService.Core.Concurrency;/// <summary>/// Rate limiter that enforces minimum time intervals between consecutive cache-miss requests/// for each concurrency slot. Each slot has its own independent timer./// </summary>/// <remarks>/// When a request hits the cache, no rate limiting is applied./// When a request misses the cache, the slot must wait for the configured interval/// since its last cache-miss request before allowing another cache-miss request./// </remarks>public class ProviderRateLimiter{    private readonly TimeSpan _minInterval;    private readonly ConcurrentDictionary<int, DateTimeOffset> _slotLastRequestTime;    public ProviderRateLimiter(TimeSpan minInterval)    {        _minInterval = minInterval;        _slotLastRequestTime = new ConcurrentDictionary<int, DateTimeOffset>();    }    /// <summary>    /// Checks if the slot can proceed with a cache-miss request, and waits if necessary.    /// </summary>    /// <param name="slotId">The concurrency slot ID (0-based index)</param>    /// <param name="ct">Cancellation token</param>    /// <returns>Task that completes when the rate limit allows the request</returns>    public async Task WaitIfNeededAsync(int slotId, CancellationToken ct)    {        if (_minInterval == TimeSpan.Zero)        {            // Rate limiting disabled            return;        }        var now = DateTimeOffset.UtcNow;                // Get the last request time for this slot        if (_slotLastRequestTime.TryGetValue(slotId, out var lastRequestTime))        {            var elapsed = now - lastRequestTime;            var remaining = _minInterval - elapsed;                        if (remaining > TimeSpan.Zero)            {                // Need to wait                await Task.Delay(remaining, ct).ConfigureAwait(false);            }        }                // Update the last request time for this slot        _slotLastRequestTime[slotId] = DateTimeOffset.UtcNow;    }    /// <summary>    /// Calculates how much time needs to wait before the next cache-miss request for a slot.    /// </summary>    /// <param name="slotId">The concurrency slot ID</param>    /// <returns>TimeSpan indicating wait time, or TimeSpan.Zero if no wait needed</returns>    public TimeSpan GetWaitTime(int slotId)    {        if (_minInterval == TimeSpan.Zero)        {            return TimeSpan.Zero;        }        if (_slotLastRequestTime.TryGetValue(slotId, out var lastRequestTime))        {            var elapsed = DateTimeOffset.UtcNow - lastRequestTime;            var remaining = _minInterval - elapsed;            return remaining > TimeSpan.Zero ? remaining : TimeSpan.Zero;        }        return TimeSpan.Zero;    }    /// <summary>    /// Clears the rate limit history for all slots.    /// </summary>    public void Reset()    {        _slotLastRequestTime.Clear();    }    /// <summary>    /// Gets statistics about slot usage.    /// </summary>    public RateLimiterStatistics GetStatistics()    {        var now = DateTimeOffset.UtcNow;        var activeSlots = _slotLastRequestTime.Count;        var waitingSlots = 0;        foreach (var kvp in _slotLastRequestTime)        {            var elapsed = now - kvp.Value;            if (elapsed < _minInterval)            {                waitingSlots++;            }        }        return new RateLimiterStatistics        {            ActiveSlots = activeSlots,            WaitingSlots = waitingSlots,            MinInterval = _minInterval        };    }}/// <summary>/// Rate limiter statistics./// </summary>public class RateLimiterStatistics{    public int ActiveSlots { get; set; }    public int WaitingSlots { get; set; }    public TimeSpan MinInterval { get; set; }}/// <summary>/// Hanime-specific rate limiter./// </summary>public sealed class HanimeRateLimiter : ProviderRateLimiter{    public HanimeRateLimiter(TimeSpan minInterval) : base(minInterval) { }}/// <summary>/// DLsite-specific rate limiter./// </summary>public sealed class DlsiteRateLimiter : ProviderRateLimiter{    public DlsiteRateLimiter(TimeSpan minInterval) : base(minInterval) { }}