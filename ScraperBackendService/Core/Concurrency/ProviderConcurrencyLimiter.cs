using System.Threading;using System.Collections.Concurrent;namespace ScraperBackendService.Core.Concurrency;/// <summary>/// Controls the maximum number of concurrent requests to a specific provider./// Each acquired slot has a unique ID for tracking and rate limiting purposes./// </summary>public class ProviderConcurrencyLimiter{    private readonly SemaphoreSlim _sem;    private readonly int _max;    private readonly ConcurrentQueue<int> _availableSlots;    private int _nextSlotId;        /// <summary>    /// Gets the provider name for this limiter instance.    /// </summary>    public string ProviderName { get; }    /// <summary>    /// Initializes a new instance of the ProviderConcurrencyLimiter class.    /// </summary>    /// <param name="maxConcurrent">Maximum number of concurrent operations allowed</param>    /// <param name="providerName">Optional provider name for identification</param>    public ProviderConcurrencyLimiter(int maxConcurrent, string? providerName = null)    {        _max = maxConcurrent <= 0 ? 1 : maxConcurrent;        _sem = new SemaphoreSlim(_max, _max);        _availableSlots = new ConcurrentQueue<int>();        _nextSlotId = 0;        ProviderName = providerName ?? "Unknown";        // Initialize available slots        for (int i = 0; i < _max; i++)        {            _availableSlots.Enqueue(i);        }    }    /// <summary>    /// Waits for a slot to become available and returns the acquired slot ID.    /// </summary>    /// <param name="ct">Cancellation token</param>    /// <returns>A concurrency slot that should be disposed when the operation completes</returns>    public async Task<ConcurrencySlot> WaitAndAcquireSlotAsync(CancellationToken ct)    {        await _sem.WaitAsync(ct);        // Get an available slot ID        if (_availableSlots.TryDequeue(out var slotId))        {            return new ConcurrencySlot(this, slotId);        }        // Fallback: create a new slot ID if queue is empty (shouldn't happen)        slotId = Interlocked.Increment(ref _nextSlotId) % _max;        return new ConcurrencySlot(this, slotId);    }    /// <summary>    /// Tries to acquire a slot with timeout and returns the slot ID if successful.    /// </summary>    /// <param name="millisecondsTimeout">Timeout in milliseconds</param>    /// <param name="ct">Cancellation token</param>    /// <returns>A concurrency slot if acquired within timeout, null otherwise</returns>    public async Task<ConcurrencySlot?> TryWaitAndAcquireSlotAsync(int millisecondsTimeout, CancellationToken ct)    {        var acquired = await _sem.WaitAsync(millisecondsTimeout, ct);        if (!acquired)        {            return null;        }        // Get an available slot ID        if (_availableSlots.TryDequeue(out var slotId))        {            return new ConcurrencySlot(this, slotId);        }        // Fallback: create a new slot ID if queue is empty        slotId = Interlocked.Increment(ref _nextSlotId) % _max;        return new ConcurrencySlot(this, slotId);    }    /// <summary>    /// Waits for a slot to become available (legacy method for compatibility).    /// </summary>    public Task WaitAsync(CancellationToken ct) => _sem.WaitAsync(ct);    /// <summary>    /// Tries to acquire a slot with timeout (legacy method for compatibility).    /// </summary>    public Task<bool> TryWaitAsync(int millisecondsTimeout, CancellationToken ct) => _sem.WaitAsync(millisecondsTimeout, ct);    /// <summary>    /// Releases a slot (legacy method for compatibility).    /// </summary>    public void Release() => _sem.Release();    /// <summary>    /// Releases a specific slot and makes it available for reuse.    /// </summary>    internal void ReleaseSlot(int slotId)    {        _availableSlots.Enqueue(slotId);        _sem.Release();    }    /// <summary>    /// Disposes the limiter and releases all resources.    /// </summary>    public void Dispose() => _sem.Dispose();    /// <summary>    /// Current available slots in the limiter (for diagnostics).    /// </summary>    public int CurrentCount => _sem.CurrentCount;    /// <summary>    /// Configured maximum concurrent slots.    /// </summary>    public int MaxCount => _max;}/// <summary>/// Represents an acquired concurrency slot that should be disposed when done./// Each slot has a unique ID for tracking and rate limiting purposes./// </summary>public sealed class ConcurrencySlot : IDisposable{    private readonly ProviderConcurrencyLimiter _limiter;    private bool _disposed;    /// <summary>    /// Gets the unique identifier for this concurrency slot.    /// </summary>    public int SlotId { get; }    internal ConcurrencySlot(ProviderConcurrencyLimiter limiter, int slotId)    {        _limiter = limiter;        SlotId = slotId;    }    /// <summary>    /// Releases the concurrency slot back to the limiter.    /// </summary>    public void Dispose()    {        if (!_disposed)        {            _limiter.ReleaseSlot(SlotId);            _disposed = true;        }    }}