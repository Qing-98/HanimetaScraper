using ScraperBackendService.Configuration;using ScraperBackendService.Extensions;using ScraperBackendService.Middleware;using ScraperBackendService.Models;using ScraperBackendService.Core.Logging;using ScraperBackendService.Core.Caching;using System.Text.Json;var builder = WebApplication.CreateBuilder(args);// Load configurationvar serviceConfig = new ServiceConfiguration();builder.Configuration.GetSection(ServiceConfiguration.SectionName).Bind(serviceConfig);// Override with command line argumentsif (args.Length > 0 && int.TryParse(args[0], out var port))    serviceConfig.Port = port;// Override with environment variablesvar envPort = Environment.GetEnvironmentVariable("SCRAPER_PORT");if (!string.IsNullOrEmpty(envPort) && int.TryParse(envPort, out var ePort))    serviceConfig.Port = ePort;var envToken = Environment.GetEnvironmentVariable("SCRAPER_AUTH_TOKEN");if (!string.IsNullOrEmpty(envToken))    serviceConfig.AuthToken = envToken;// Configure logging with strict level enforcementbuilder.Logging.ClearProviders();builder.Logging.AddConsole();// Set minimum level to Warning to prevent Info logs from appearingbuilder.Logging.SetMinimumLevel(LogLevel.Warning);// Apply Warning level filters to all Microsoft componentsbuilder.Logging.AddFilter("Microsoft.AspNetCore", LogLevel.Warning);builder.Logging.AddFilter("Microsoft.Extensions.Hosting", LogLevel.Warning);builder.Logging.AddFilter("Microsoft.AspNetCore.Hosting.Diagnostics", LogLevel.Error);builder.Logging.AddFilter("Microsoft.AspNetCore.Routing.EndpointMiddleware", LogLevel.Error);builder.Logging.AddFilter("Microsoft.AspNetCore.StaticFiles", LogLevel.Error);builder.Logging.AddFilter("Microsoft", LogLevel.Warning);builder.Logging.AddFilter("System", LogLevel.Warning);// Set our app to Warning level toobuilder.Logging.AddFilter("ScraperBackendService", LogLevel.Warning);// Register servicesbuilder.Services.AddScrapingServices(serviceConfig);builder.Services.AddSingleton<MetadataCache>();builder.Services.AddHostedService<PlaywrightCleanupService>();// Configure JSON serializationbuilder.Services.Configure<JsonSerializerOptions>(options =>{    options.PropertyNamingPolicy = JsonNamingPolicy.CamelCase;    options.WriteIndented = true;});var app = builder.Build();// Middlewareapp.UseMiddleware<TokenAuthenticationMiddleware>();app.UseMiddleware<MemoryOptimizationMiddleware>();// Request timeoutapp.Use(async (context, next) =>{    using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(serviceConfig.RequestTimeoutSeconds));    using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(context.RequestAborted, cts.Token);    context.RequestAborted = linkedCts.Token;    await next();});var logger = app.Services.GetRequiredService<ILogger<Program>>();// Startup dependency check and key configuration logging (minimal)try{    using var scope = app.Services.CreateScope();    var sp = scope.ServiceProvider;    // Ensure critical services resolve    sp.GetRequiredService<MetadataCache>();    logger.LogAlways("ServiceStartup", "Dependency check: MetadataCache OK");    var ctxMgr = sp.GetService<ScraperBackendService.AntiCloudflare.PlaywrightContextManager>();    if (ctxMgr != null)    {        logger.LogAlways("ServiceStartup", "Dependency check: PlaywrightContextManager OK");    }    // Log key configuration values    logger.LogAlways("ServiceStartup",        $"Config: Timeout={serviceConfig.RequestTimeoutSeconds}s, RateLimit={serviceConfig.RateLimitSeconds}s, MaxConcurrent={serviceConfig.MaxConcurrentRequests}");}catch (Exception ex){    logger.LogFailure("ServiceStartup", "Dependency/config validation failed", null, ex);    throw;}// Global exception handlerapp.UseExceptionHandler(errorApp =>{    errorApp.Run(async context =>    {        var feature = context.Features.Get<Microsoft.AspNetCore.Diagnostics.IExceptionHandlerFeature>();        var ex = feature?.Error;        if (ex != null)        {            logger.LogError(ex, "Unhandled exception in request pipeline");        }        context.Response.StatusCode = 500;        await context.Response.WriteAsync("Internal server error");    });});// Unhandled exception handlersAppDomain.CurrentDomain.UnhandledException += (s, e) =>{    if (e.ExceptionObject is Exception ex)    {        logger.LogError(ex, "Unhandled domain exception");    }    else    {        logger.LogError("Unhandled domain exception: {Obj}", e.ExceptionObject?.ToString() ?? "<null>");    }};TaskScheduler.UnobservedTaskException += (s, e) =>{    logger.LogError(e.Exception, "Unobserved task exception");    e.SetObserved();};// Base endpointsapp.MapGet("/", () =>{    return Results.Json(ApiResponse<ServiceInfo>.Ok(new ServiceInfo    {        AuthEnabled = !string.IsNullOrWhiteSpace(serviceConfig.AuthToken)    }));});app.MapGet("/health", () => Results.Json(new { status = "healthy", timestamp = DateTime.UtcNow }));// Cache endpointsapp.MapGet("/cache/stats", (MetadataCache cache) =>{    var stats = cache.GetStatistics();    return Results.Json(new    {        hitCount = stats.HitCount,        missCount = stats.MissCount,        evictionCount = stats.EvictionCount,        totalRequests = stats.TotalRequests,        hitRatio = $"{stats.HitRatio:P2}",        timestamp = DateTime.UtcNow    });});app.MapDelete("/cache/clear", (MetadataCache cache) =>{    cache.Clear();    return Results.Json(new { message = "Cache cleared successfully", timestamp = DateTime.UtcNow });});app.MapDelete("/cache/{provider}/{id}", (string provider, string id, MetadataCache cache) =>{    cache.Remove(provider, id);    return Results.Json(new { message = $"Cache entry removed for {provider}:{id}", timestamp = DateTime.UtcNow });});// DLsite redirect endpointapp.MapGet("/r/dlsite/{id}", (string id) =>{    try    {        var target = ScraperBackendService.Core.Routing.IdParsers.BuildDlsiteDetailUrl(id);        return Results.Redirect(target);    }    catch (Exception ex)    {        logger.LogWarning(ex, "Failed to build DLsite redirect for id={Id}", id);        return Results.NotFound();    }});// =============== Auto-Register Provider API Endpoints ===============// All provider endpoints are automatically registered by ProviderRegistryforeach (var providerConfig in ScraperBackendService.Providers._Registry.ProviderRegistry.GetAllProviders()){    ScraperBackendService.Providers._Registry.ProviderRegistry.MapProviderEndpoints(app, providerConfig, logger);}// Start servicevar listenUrl = $"http://{serviceConfig.Host}:{serviceConfig.Port}";logger.LogAlways("ServiceStartup", $"Listening on {listenUrl}");var authStatus = string.IsNullOrWhiteSpace(serviceConfig.AuthToken) ? "Disabled" : "Enabled";logger.LogAlways("ServiceStartup", $"Authentication: {authStatus}");var lifetime = app.Lifetime;lifetime.ApplicationStopping.Register(() => logger.LogAlways("ServiceShutdown", "Stopping service"));lifetime.ApplicationStopped.Register(() => logger.LogAlways("ServiceShutdown", "Service stopped"));Console.CancelKeyPress += (_, e) =>{    logger.LogAlways("ServiceShutdown", "CancelKeyPress received - stopping");};AppDomain.CurrentDomain.ProcessExit += (_, _) => logger.LogAlways("ServiceShutdown", "Process exiting");try{    app.Run(listenUrl);}catch (Exception ex){    logger.LogFailure("ServiceStartup", "Service failed to start", listenUrl, ex);    throw;}